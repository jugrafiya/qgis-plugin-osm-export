# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OSMExportDialog
                                 A QGIS plugin
 A plugin to download OSM data for the current map extent and export it to a file.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-31
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Jugrafiya
        email                : muhammad.tayyab@jugrafiya.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QDialog, QMessageBox, QPushButton
from qgis.core import QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsProject, QgsPointXY, QgsGeometry, QgsFeature, QgsVectorLayer, QgsField, QgsWkbTypes, QgsProcessingFeedback, QgsVectorFileWriter
from PyQt5.QtCore import QVariant
import requests
import overpy
import processing

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'osm_export_dialog_base.ui'))


class OSMExportDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(OSMExportDialog, self).__init__(parent)

        self.setupUi(self)
        self.iface = iface

        # Connect the button click event to the method
        self.btnShowExtent.clicked.connect(self.show_current_extent)

    def download_osm_data(self, in_extent):
        # Convert the extent to a bounding box string for the Overpass API
        bbox = f"{in_extent.yMinimum()},{in_extent.xMinimum()},{in_extent.yMaximum()},{in_extent.xMaximum()}"

        # Construct Overpass query focusing on ways and relations for lines and polygons
        query = f"""
        [out:json];
        (
        way({bbox});
        relation({bbox});
        );
        (._;>;);
        out body;
        """


        api = overpy.Overpass()
        result = api.query(query)
        # Create a memory layer for ways (lines)
        way_layer = QgsVectorLayer("LineString?crs=epsg:4326", "OSM Ways", "memory")
        way_prov = way_layer.dataProvider()
        way_prov.addAttributes([QgsField("id", QVariant.String),
                                QgsField("highway", QVariant.String),
                                QgsField("name", QVariant.String)])
        way_layer.updateFields()

        # Create a memory layer for relations (polygons)
        relation_layer = QgsVectorLayer("MultiPolygon?crs=epsg:4326", "OSM Relations", "memory")
        relation_prov = relation_layer.dataProvider()
        relation_prov.addAttributes([QgsField("id", QVariant.String),
                                    # QgsField("type", QVariant.String),
                                    QgsField("name", QVariant.String)])
        relation_layer.updateFields()

        
        # Process ways as lines
        for way in result.ways:
            points = [QgsPointXY(float(node.lon), float(node.lat)) for node in way.nodes]
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromPolylineXY(points))
            feat.setAttributes([str(way.id), way.tags.get("highway", ""), way.tags.get("name", "")])
            way_prov.addFeature(feat)
        print("Field Added.")
        # Process relations as polygons
        for relation in result.relations:
            outer_ring = []
            for member in relation.members:
                print(member.role, "  #  ")
                # if member.role == "outer":
                way = result.get_way(member.ref)
                outer_ring.extend([QgsPointXY(float(node.lon), float(node.lat)) for node in way.nodes])
            if outer_ring:  # Check if outer ring is not empty
                # Close the polygon if it's not closed
                if outer_ring[0] != outer_ring[-1]:
                    outer_ring.append(outer_ring[0])
                feat = QgsFeature()
                feat.setGeometry(QgsGeometry.fromPolygonXY([outer_ring]))
                feat.setAttributes([str(relation.id), relation.tags.get("name", "")])
                relation_prov.addFeature(feat)


        return {"WAY_LAYER": way_layer, "RELATION_LAYER": relation_layer}

        # Add the layers to the map
        QgsProject.instance().addMapLayer(way_layer)
        QgsProject.instance().addMapLayer(relation_layer)

        return {"WAY_LAYER": way_layer, "RELATION_LAYER": relation_layer}

    def show_current_extent(self):
        # Get the current map extent
        extent = self.iface.mapCanvas().extent()

        # Calculate the center of the extent
        center_x = (extent.xMinimum() + extent.xMaximum()) / 2
        center_y = (extent.yMinimum() + extent.yMaximum()) / 2

        # Create a point at the center
        center_point = QgsPointXY(center_x, center_y)

        # Check if the map is already in a geographic coordinate system
        map_crs = self.iface.mapCanvas().mapSettings().destinationCrs()
        geo_crs = QgsCoordinateReferenceSystem('EPSG:4326')  # WGS 84

        # Transform the center point to geographic coordinates if necessary
        if map_crs != geo_crs:
            transform = QgsCoordinateTransform(map_crs, geo_crs, QgsProject.instance())
            center_point = transform.transform(center_point)

        # Calculate the UTM zone from the longitude
        utm_zone = int((center_point.x() + 180) / 6) + 1

        # Transform the extent to WGS 84
        transform = QgsCoordinateTransform(map_crs, geo_crs, QgsProject.instance())
        extent_84 = transform.transform(extent)


        try:
            # Use the above funtion to dWownload and display OSM data
            osmdata = self.download_osm_data(extent_84)

            way_layer = osmdata["WAY_LAYER"]
            relation_layer = osmdata["RELATION_LAYER"]

            # Add the layers to the map
            QgsProject.instance().addMapLayer(osmdata["WAY_LAYER"])
            QgsProject.instance().addMapLayer(osmdata["RELATION_LAYER"])


            QMessageBox.information(
                None, "OSM Data Download", f"Successfully downloaded OSM data for the current extent.", QMessageBox.Ok)
            # Here you could process the result or save it to a file, etc.

        except overpy.exception.OverpassTooManyRequests:
            QMessageBox.warning(
                None, "OSM Data Download", "Too many requests to Overpass API. Please try again later.", QMessageBox.Ok)
        except Exception as e:
            QMessageBox.warning(
                None, "OSM Data Download", f"An error occurred: {str(e)}", QMessageBox.Ok)

    
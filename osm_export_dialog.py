# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OSMExportDialog
                                 A QGIS plugin
 A plugin to download OSM data for the current map extent and export it to a file.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-31
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Jugrafiya
        email                : muhammad.tayyab@jugrafiya.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QDialog, QMessageBox, QPushButton, QFileDialog
from qgis.core import QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsProject, QgsPointXY, QgsGeometry, QgsFeature, QgsVectorLayer, QgsField, QgsWkbTypes, QgsProcessingFeedback, QgsVectorFileWriter, QgsCoordinateTransformContext
from PyQt5.QtCore import QVariant
import requests
import overpy
import processing

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'osm_export_dialog_base.ui'))


class OSMExportDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(OSMExportDialog, self).__init__(parent)

        self.setupUi(self)
        self.iface = iface

        # Connect the button click event to the method
        self.btnShowExtent.clicked.connect(self.show_current_extent)
        self.btnSelectDXFFile.clicked.connect(self.selectDXFFile)

        # Make lineEditDXFFileName read-only
        self.lineEditDXFFileName.setReadOnly(True)

    def selectDXFFile(self):
        # Open a file dialog to select the DXF file
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileName, _ = QFileDialog.getSaveFileName(self, "Select DXF File", "", "DXF Files (*.dxf);;All Files (*)", options=options)

        if fileName:
            # Set the selected file name in the line edit

            # Add the .dxf extension if not already present
            if not fileName.endswith(".dxf"):
                fileName += ".dxf"

            self.lineEditDXFFileName.setText(fileName)

    def download_osm_data(self, in_extent):

        if self.lineEditDXFFileName.text() == "":
            QMessageBox.warning(
                None, "OSM Data Download", "Please select a DXF file to save the output.", QMessageBox.Ok)
            return

        # Convert the extent to a bounding box string for the Overpass API
        bbox = f"{in_extent.yMinimum()},{in_extent.xMinimum()},{in_extent.yMaximum()},{in_extent.xMaximum()}"

        # Construct Overpass query focusing on ways and relations for lines and polygons
        query = f"""
        [out:json];
        (
        way({bbox});
        );
        (._;>;);
        out body;
        """

        api = overpy.Overpass()
        result = api.query(query)
        # Create a memory layer for ways (lines)
        way_layer = QgsVectorLayer("LineString?crs=epsg:4326", "OSM Data", "memory")
        way_prov = way_layer.dataProvider()
        # Add fields to the layer
        way_prov.addAttributes([QgsField("type", QVariant.String)])
        way_layer.updateFields()
        
        
        # Process ways as lines
        for way in result.ways:
            points = [QgsPointXY(float(node.lon), float(node.lat)) for node in way.nodes]
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromPolylineXY(points))
            feat.setAttributes([way.tags.get("highway", way.tags.get("leisure", way.tags.get("landuse", way.tags.get("building", way.tags.get("amenity","unknown")).replace("yes", "Built Up Area"))))])
            way_prov.addFeature(feat)

            
        return {"WAY_LAYER": way_layer}

    def show_current_extent(self):
        # Get the current map extent
        extent = self.iface.mapCanvas().extent()

        # Calculate the center of the extent
        center_x = (extent.xMinimum() + extent.xMaximum()) / 2
        center_y = (extent.yMinimum() + extent.yMaximum()) / 2

        # Create a point at the center
        center_point = QgsPointXY(center_x, center_y)

        # Check if the map is already in a geographic coordinate system
        map_crs = self.iface.mapCanvas().mapSettings().destinationCrs()
        geo_crs = QgsCoordinateReferenceSystem('EPSG:4326')  # WGS 84

        # Transform the center point to geographic coordinates if necessary
        if map_crs != geo_crs:
            transform = QgsCoordinateTransform(map_crs, geo_crs, QgsProject.instance())
            center_point = transform.transform(center_point)

        # Calculate the UTM zone from the longitude
        utm_zone = int((center_point.x() + 180) / 6) + 1

        # Transform the extent to WGS 84
        transform = QgsCoordinateTransform(map_crs, geo_crs, QgsProject.instance())
        extent_84 = transform.transform(extent)

        # try:
        # Use the above funtion to dWownload and display OSM data
        osmdata = self.download_osm_data(extent_84)

        way_layer = osmdata["WAY_LAYER"]
        output_file = self.lineEditDXFFileName.text()
        
        # Get file name from the last part of the path
        out_file_name = os.path.basename(output_file).replace(".dxf", "")

        # Add the layer to the map
        # QgsProject.instance().addMapLayer(way_layer)

        # Set the CRS to utm_zone
        crs = QgsCoordinateReferenceSystem(f'EPSG:{32600 + utm_zone}')

        # Set the desired CRS for the output shapefile
        output_crs = QgsCoordinateReferenceSystem(f'EPSG:{32600 + utm_zone}')

        # Export the layer to a Shapefile
        # Create a transform object to convert between EPSG:4326 and target epsg
        target_epsg = 32600 + utm_zone
        source_crs = QgsCoordinateReferenceSystem(4326)
        target_crs = QgsCoordinateReferenceSystem(target_epsg)
        transform = QgsCoordinateTransform(source_crs, target_crs, QgsCoordinateTransformContext())

        # Create a new memory layer for the reprojected ways
        reprojected_way_layer = QgsVectorLayer("LineString?crs=epsg:target_epsg", "Reprojected OSM Data", "memory")
        reprojected_way_prov = reprojected_way_layer.dataProvider()
        reprojected_way_prov.addAttributes([QgsField("Layer", QVariant.String)])
        reprojected_way_layer.updateFields()

        # Transfer features from the original layer to the new one, transforming their geometry
        for feature in way_layer.getFeatures():
            type_value = feature['type']
            new_feat = QgsFeature(reprojected_way_prov.fields())
            # Transform the geometry
            transformed_geom = feature.geometry()
            transformed_geom.transform(transform)
            new_feat.setGeometry(transformed_geom)
            new_feat['Layer'] = type_value
            reprojected_way_prov.addFeature(new_feat)

        # Add the reprojected layer to the map (optional)
        # QgsProject.instance().addMapLayer(reprojected_way_layer)

        # Set the options for the DXF export
        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "DXF"
        options.fileEncoding = "UTF-8"
        options.dstCRS = crs
        options.layerOptions = [
        "USE_TITLE_AS_LAYERNAME=NO",  # Do not use the layer title as the DXF layer name
        "USE_LAYERID_AS_LAYERNAME=NO",  # Do not use the layer ID as the DXF layer name
        "USE_ATTRIBUTES=YES",  # Export attributes
        "ATTRIBUTE_LAYER=Layer"  # Use the 'type' attribute for layer names in the DXF
        ]
        options.attributes = []

        # Perform the export
        error = QgsVectorFileWriter.writeAsVectorFormatV3(
            layer=reprojected_way_layer,
            fileName=output_file,
            transformContext=QgsProject.instance().transformContext(),
            options=options
        )

        layer_name = way_layer.name()
        if error[0] == QgsVectorFileWriter.NoError:
            print(f"Layer '{layer_name}' successfully exported to '{output_file}'.")
        else:
            print(f"Failed to export '{layer_name}': {error}")

        # load the dxf file to the map
        layerDxf = QgsVectorLayer(output_file, out_file_name , "ogr")

        # Set the CRS to utm_zone
        crs = QgsCoordinateReferenceSystem(f'EPSG:{32600 + utm_zone}')
        layerDxf.setCrs(crs)
        
        QgsProject.instance().addMapLayer(layerDxf)

        # if result == QgsVectorFileWriter.NoError:
        #     print(f"Layer '{layer_name}' successfully exported to '{output_file}'.")
        # else:
        #     print(f"Failed to export '{layer_name}': {error}")



        QMessageBox.information(
            None, "OSM Data Download", f"Successfully downloaded OSM data for the current extent.", QMessageBox.Ok)
        # Here you could process the result or save it to a file, etc.

        # except overpy.exception.OverpassTooManyRequests:
        #     QMessageBox.warning(
        #         None, "OSM Data Download", "Too many requests to Overpass API. Please try again later.", QMessageBox.Ok)
        # except Exception as e:
        #     QMessageBox.warning(
        #         None, "OSM Data Download", f"An error occurred: {str(e)}", QMessageBox.Ok)

    